---
tags:
---
---

Связи:
- [[Практика языка C (МФТИ, 2023-2024). Семинар 5.1. Строки и символы]]
- 

---

Источник:
- [Печать и чтение строк — Шаг 1 — Stepik](https://stepik.org/lesson/275992/step/1?unit=257133)
- 

---

Ключевые идеи:
 - идея1
 - 

---
### Массив символов

В си нет строкового типа
**Строка** - это последовательность символов, оканчивающихся символом `'\0'`

В языке С нет специального типа для работы со строками. Для этого используются массивы с элементами типа `char` и указатели `char *`.

```c
char a[10] = {'a', 'b', '\0'};
char * a2 = "hello";
```

---

### Длина строки

``char s[] = "Hello"; 
``size1 = strlen(s)  // 5 (без \0) 
``size2 = sizeof(s)  // 6 (место в памяти все элементы \0 тоже)

---

### Массив или указатель?

```c
char s1[] = "world"; // массив из 6 символов 
char * s2 = "world"; // 1 указатель на char, указывает на строковую константу "world"
```

- `sizeof(s1) == 6`
- `sizeof(s2) == sizeof(void*)` и равен размеру любого другого адреса, сколько конкретно - зависит от архитектуры (скорее всего 4 для 32-битного компилятора и 8 для 64-битного).

```c
s1[0] = 'H'; // заменит в массиве первый символ на H 
s2[0] = 'W'; // программа упадет, так как нельзя писать в read only область памяти
```

Если нужно изменять строку, её надо либо выделять динамически, либо использовать массив символов

```c
int main(int argc, char **argv, char **env)
{
	char * s = NULL;
	scanf("%ms", &s);
	s[0] = '!';  // сработает потму что память выделяется malloc ом и хранится в heap (куче) - Динамическая память (heap)
	printf("s1 = %s\n", s);
	
	char * s2 = "world"; // указатель на char, указывает на строковую константу "world"
    s2[0] = '!'; // программа упадет, так как нельзя писать в read only область памяти
	printf("s2 = %s\n", s2);
	
	
	free(s);
	return 0;
}
```

---

### Сравнение строк

`s1 == s2` - проверяем, что `s1` и `s2` указывают на одну и ту же область памяти. Это сравнение на равенство указателей, а не содержимого, на которые они указывают. Для сравнения строк используют функции `strcmp` и `strncmp`


```cpp
char b1[] = "world";    // пусть массив начинается с адреса 100
char b2[] = "world";    // пусть массив начинается с адреса 200

if (b1 == b2)           // 100 == 200 - сравнение указателей - ложь
    printf("равны\n");
else
    printf("НЕ равны\n");

if (0 == strcmp(b1, b2)) // истина, строки одинаковые
    printf("равны\n");
else
    printf("НЕ равны\n");
```

`b1 == b2` сравнивает адреса начала этих массивов. Если один массив расположен начиная с адреса 100, а другой начиная с адреса 200, то очевидно, что `100 == 200` - ложь.

`0 == strcmp(b1, b2)` у строк b1 и b2 нулевая разница (то есть они одинаковые). Истина.

---

### Чтение строки

```c
#include <stdio.h> 
int main() { 
	char a[10] = "hello"; 
	scanf("%3s", a); // читаем в массив а НЕ БОЛЕЕ 3 символов 
	printf("%s\n", a); //
	return 0; 
}
```

scanf  читает не всю строку, а "слово" до пробельного символа (пробела, табуляции, \n и так далее).

fgets - чтение строки
Читает из потока `stream` и записывает в буфер `s` строку до `'\n'`, но не более `size` символов
При успешном чтении функция fgets() возвращает указатель s, переданный ей в качестве аргумента, иначе NULL.

```c
#include <stdio.h>
int main() {
    char a[10];
    fgets(a, 5, stdin);    // читаем и ЗАПИСЫВАЕМ в массив а
                           // НЕ БОЛЕЕ 5 символов с stdin (клавиатуры)
    printf("<%s>\n", a);   // печатаем прочитанное
    return 0;
}
```



---

Передача массива  в функцию

Массив в функцию не копируется, передается адрес начала массива

`` void foo(int a[10])
`` void foo(int a[])
`` void foo(int * a)
